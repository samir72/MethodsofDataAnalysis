install.packages("fivethirtyeight")
getwd()
setwd('C:\\Users\\rr657c\\Documents\\UW\\Data Science Certificate\\Methods of Data Analysis\\Lecture2')
# Clear objects from Memory
rm(list=ls())
# Clear Console:
cat("\014")
library(MASS) # Contains the function 'fractions()',
##-----Sandwich Count----
breads = c('white', 'wheat', 'italian', 'sevengrain')
meats = c('ham', 'turkey', 'chicken', 'pastrami', 'meatballs')
toppings = c('mustard', 'mayo', 'salt_pepper', 'oil_vinegar')
cheese = c('swiss', 'american', 'chedar')
sandwiches = expand.grid(breads,
meats,
toppings)
View(sandwiches)
source('~/UW/Data Science Certificate/Methods of Data Analysis/Lecture2/Counting.R')
rm(list=ls())
# Clear Console:
cat("\014")
library(MASS) # Contains the function 'fractions()',
##-----Sandwich Count----
breads = c('white', 'wheat', 'italian', 'sevengrain')
meats = c('ham', 'turkey', 'chicken', 'pastrami', 'meatballs')
toppings = c('mustard', 'mayo', 'salt_pepper', 'oil_vinegar')
cheese = c('swiss', 'american', 'chedar')
sandwiches = expand.grid(breads,
meats,
toppings)
nrow(sandwiches)
sandwiches
sandwiches2 = expand.grid(breads,
meats,
cheese,
toppings)
nrow(sandwiches2)
sandwiches2
twoDice = expand.grid(1:6,1:6)
View(twoDice)
twoDice
twoDice$sum = twoDice$Var1 + twoDice$Var2
twoDice$isdouble = twoDice$Var1 == twoDice$Var2 ## == is logical equals
twoDice
sumCounts = table(twoDice$sum)
sumCounts
doubles = sum(twoDice$isdouble)
doubles
fractions(doubles/nrow(twoDice))
?fractions
nrow(twoDice)
table(twoDice$sum)
sumProb = fractions(table(twoDice$sum)/nrow(twoDice)) # type ?fractions for detail
sumProb
>barplot()
? barplot
barplot(sumProb)
# Clear objects from Memory
rm(list=ls())
# Clear Console:
cat("\014")
class(NA)
class(NaN)
class(NULL)
0/0
sqrt(-1)
log(-1)
asin(2)
NaN > 1
sum(c(1,2,NaN))
sum(c(1,2,NaN), na.rm=TRUE)
c(1,2)[3]
as.numeric('data')
NA > 1
sum(c(1,2,NA))
sum(c(1,2,NA), na.rm=TRUE)
t = data.frame('a'=1:4, 'b'=runif(4))
?runif
t
t$c
t$a = NULL
t
s = c(1,2,NULL)
s
library(Amelia)
?Amelia
??Amelia
install.packages(Amelia)
install.packages("Amelia")
library(Amelia)
n = 1000
full_data = data.frame('A'=runif(n),
'B'=rnorm(n),
'C'=rpois(n, 5))
?apply
sample_means = apply(full_data, 2, mean)
sample_means
?mean
sample_sds = apply(full_data, 2, sd)
sample_sds
sample_sds = apply(full_data, 2, sd)
sample_sds
?apply
data$A[sample(1:n, round(n*0.05))] = NA
data
data
data = full_data
data$A[sample(1:n, round(n*0.05))] = NA
data$A
data$B[sample(1:n, round(n*0.15))] = NA
data$C[sample(1:n, round(n*0.5))] = NA
rm(list=ls())
# Clear Console:
cat("\014")
# NA vs. NaN vs. NULL
class(NA)
class(NaN)
class(NULL)
# NaNs:
0/0
sqrt(-1)
log(-1)
asin(2)
NaN > 1
## Note that na.rm is quite general, NaN is not a type of NA
sum(c(1,2,NaN))
sum(c(1,2,NaN), na.rm=TRUE)
#NAs:
c(1,2)[3]          # third argument missing
as.numeric('data') # R is 'missing' the number available
NA > 1
sum(c(1,2,NA))
sum(c(1,2,NA), na.rm=TRUE)
# NULLs:
t = data.frame('a'=1:4, 'b'=runif(4))
t
t$c
t$a = NULL
t
s = c(1,2,NULL)
s
# To illustrate the helpfulness of Multiple Imputation,
#   we will test this out on a contrived data set
library(Amelia)
n = 1000
full_data = data.frame('A'=runif(n),
'B'=rnorm(n),
'C'=rpois(n, 5))
# true mean of A = 0.5
# true mean of B = 0
# true mean of C = 5
sample_means = apply(full_data, 2, mean)
sample_means
sample_sds = apply(full_data, 2, sd)
sample_sds
# Remove some data:
data = full_data
nrow[data]
nrow[data$A]
data
head(data
)
nrow(data)
?sample
data$A[sample(1:n, round(n*0.05))] = NA
head(data)
data$A
nrow(data$A)
nrow(data)
ncol(data)
head(data)
names(data)
data$A = NA
head(data)
rm(list=ls())
# Clear Console:
cat("\014")
# NA vs. NaN vs. NULL
class(NA)
class(NaN)
class(NULL)
# NaNs:
0/0
sqrt(-1)
log(-1)
asin(2)
NaN > 1
## Note that na.rm is quite general, NaN is not a type of NA
sum(c(1,2,NaN))
sum(c(1,2,NaN), na.rm=TRUE)
#NAs:
c(1,2)[3]          # third argument missing
as.numeric('data') # R is 'missing' the number available
NA > 1
sum(c(1,2,NA))
sum(c(1,2,NA), na.rm=TRUE)
# NULLs:
t = data.frame('a'=1:4, 'b'=runif(4))
t
t$c
t$a = NULL
t
s = c(1,2,NULL)
s
# To illustrate the helpfulness of Multiple Imputation,
#   we will test this out on a contrived data set
library(Amelia)
n = 1000
full_data = data.frame('A'=runif(n),
'B'=rnorm(n),
'C'=rpois(n, 5))
# true mean of A = 0.5
# true mean of B = 0
# true mean of C = 5
sample_means = apply(full_data, 2, mean)
sample_means
sample_sds = apply(full_data, 2, sd)
sample_sds
# Remove some data:
data = full_data
data$A[sample(1:n, round(n*0.05))] = NA
head(data)
data$B[sample(1:n, round(n*0.15))] = NA
head(data)
data$C[sample(1:n, round(n*0.5))] = NA
head(data)
?nrow
?NROW
dim(data)
dim(data) <- NULL
dim(data)
head(data)
rm(list=ls())
# Clear Console:
cat("\014")
# NA vs. NaN vs. NULL
class(NA)
class(NaN)
class(NULL)
# NaNs:
0/0
sqrt(-1)
log(-1)
asin(2)
NaN > 1
## Note that na.rm is quite general, NaN is not a type of NA
sum(c(1,2,NaN))
sum(c(1,2,NaN), na.rm=TRUE)
#NAs:
c(1,2)[3]          # third argument missing
as.numeric('data') # R is 'missing' the number available
NA > 1
sum(c(1,2,NA))
sum(c(1,2,NA), na.rm=TRUE)
# NULLs:
t = data.frame('a'=1:4, 'b'=runif(4))
t
t$c
t$a = NULL
t
s = c(1,2,NULL)
s
# To illustrate the helpfulness of Multiple Imputation,
#   we will test this out on a contrived data set
library(Amelia)
n = 1000
full_data = data.frame('A'=runif(n),
'B'=rnorm(n),
'C'=rpois(n, 5))
# true mean of A = 0.5
# true mean of B = 0
# true mean of C = 5
sample_means = apply(full_data, 2, mean)
sample_means
sample_sds = apply(full_data, 2, sd)
sample_sds
# Remove some data:
data = full_data
data$A[sample(1:n, round(n*0.05))] = NA
data$B[sample(1:n, round(n*0.15))] = NA
data$C[sample(1:n, round(n*0.5))] = NA
means_rem_entry = apply(data, 2, function(x) mean(x, na.rm=TRUE))
means_rem_entry
sd_rem_entry = apply(data, 2, function(x) sd(x, na.rm=TRUE))
sd_rem_entry
data2 = data[complete.cases(data),]
means_rem_rows = apply(data2, 2, mean)
means_rem_rows
sd_rem_rows = apply(data2, 2, sd)
sd_rem_rows
data3 = data.frame(lapply(data, function(x) {x[which(is.na(x))] = 0; x}))
means_subs = apply(data3, 2, mean)
means_subs
sd_subs = apply(data3, 2, sd)
sd_subs
nrow(data[which(is.na(data))])
nrow([which(is.na(data))])
nrow([which(is.na(data))])
which(is.na(data))
nrow(which(is.na(data)))
NROW(which(is.na(data)))
nrow(which(is.na(data)))
?which
which(data == "NA")
which(data == "2998")
which(data$A == "2998")
which(is.na(data))
which(!is.na(data))
which(is.na(data))
View(data)
View(data)
test <- which(is.na(data))
View(data2)
View(data2)
##----Missing Data Demo -----
## Class: PCE Data Science Methods Class
## Lecture 2
#
# NA vs. NaN vs. NULL
#
# NA: Not Available, results from missing data or an
#       out of bounds reference (Logical, niether T or F)
#
# NaN:  Not A Number: results from performing an illegal
#         mathematical action. (Numeric placeholder)
#
# NULL: This is operational.  R returns this when referencing
#         non-existent columns.  R also uses a NULL assignment
#         to remove objects. (NULL Class).
#       If you've had set theory before, think of this as the
#         'empty-set'
#
# Clear objects from Memory
rm(list=ls())
# Clear Console:
cat("\014")
# NA vs. NaN vs. NULL
class(NA)
class(NaN)
class(NULL)
# NaNs:
0/0
sqrt(-1)
log(-1)
asin(2)
NaN > 1
## Note that na.rm is quite general, NaN is not a type of NA
sum(c(1,2,NaN))
sum(c(1,2,NaN), na.rm=TRUE)
#NAs:
c(1,2)[3]          # third argument missing
as.numeric('data') # R is 'missing' the number available
NA > 1
sum(c(1,2,NA))
sum(c(1,2,NA), na.rm=TRUE)
# NULLs:
t = data.frame('a'=1:4, 'b'=runif(4))
t
t$c
t$a = NULL
t
s = c(1,2,NULL)
s
# To illustrate the helpfulness of Multiple Imputation,
#   we will test this out on a contrived data set
library(Amelia)
n = 1000
full_data = data.frame('A'=runif(n),
'B'=rnorm(n),
'C'=rpois(n, 5))
# true mean of A = 0.5
# true mean of B = 0
# true mean of C = 5
sample_means = apply(full_data, 2, mean)
sample_means
sample_sds = apply(full_data, 2, sd)
sample_sds
# Remove some data:
data = full_data
data$A[sample(1:n, round(n*0.05))] = NA
data$B[sample(1:n, round(n*0.15))] = NA
data$C[sample(1:n, round(n*0.5))] = NA
# Removal of missing data (by entry only)
#  This is only works because our statistic is calculated
#          on each row separately.
means_rem_entry = apply(data, 2, function(x) mean(x, na.rm=TRUE))
means_rem_entry
sd_rem_entry = apply(data, 2, function(x) sd(x, na.rm=TRUE))
sd_rem_entry
## Removal of missing data (by row)
data2 = data[complete.cases(data),]
means_rem_rows = apply(data2, 2, mean)
means_rem_rows
sd_rem_rows = apply(data2, 2, sd)
sd_rem_rows
## Substitue a value
data3 = data.frame(lapply(data, function(x) {x[which(is.na(x))] = 0; x}))
means_subs = apply(data3, 2, mean)
means_subs
sd_subs = apply(data3, 2, sd)
sd_subs
library(Amelia)
amelia_data = amelia(data)[1]$imputations # Amelia spits out WAY too much information.
amelia_data
amelia_data
head(data
)
head(amelia_data)
head(data)
head(amelia_data)
imp_means = lapply(amelia_data, function(x) apply(x,2,function(y) mean(y, na.rm=TRUE)))
imp_means
?apply
?lapply
?do.call
?rbind
avg_imp_means = apply( do.call(rbind, imp_means), 2, function(y) mean(y, na.rm=TRUE))
avg_imp_means
imp_sds = lapply(amelia_data, function(x) apply(x,2,function(y) sd(y, na.rm=TRUE)))
imp_sds
avg_imp_sds = apply(do.call(rbind, imp_means), 2,function(y) sd(y, na.rm=TRUE))
avg_imp_sds
# Clear objects from Memory
rm(list=ls())
# Clear Console:
cat("\014")
sim.demand <- function(n){
bread <- runif(n) # Probabilities of bread choice
ifelse(bread <= 0.5, 'white',
ifelse(bread <= 0.75, 'wheat', 'multi'))
}
demand <- sim.demand(100)
table(demand)
?runif
sim.profit <- function(n = 100, sd = 30, bake = 120, test = FALSE){
# number of bread by type
baked <- c(rep('white', times = bake/2),
rep('wheat', times = bake/4),
rep('multi', times = bake/4))
baked <- as.data.frame(table(baked))
names(baked) <- c('bread', 'baked')
arrivals <- 0
while(arrivals < 1) arrivals <- rnorm(1, mean = n, sd = sd)
demand <- sim.demand(arrivals) # demand by bread type
baked$demand <- as.data.frame(table(demand))[,2]
baked$shortfall <- baked$demand - baked$baked
baked$profit <- baked$demand -
ifelse(baked$shortfall < 0, 0.2 * -baked$shortfall,
baked$shortfall )
if(test) print(baked)
data.frame(profit = sum(baked$profit), missed = sum(baked$shortfall))
}
sim.profit(test = TRUE)
plot.profit <- function(df, bins = 50){
require(ggplot2)
require(gridExtra)
bw <- (max(df$profit) - min(df$profit))/(bins - 1)
h1 <- ggplot(df, aes(profit)) + geom_histogram(binwidth = bw) +
ggtitle('Distributions of profits') + xlab('Profits')
bw <- (max(df$missed) - min(df$missed))/(bins - 1)
h2 <- ggplot(df, aes(missed)) + geom_histogram(binwidth = bw) +
ggtitle('Distributions of people missed') + xlab('Missed')
grid.arrange(h1, h2, nrow = 1)
}
dist.profit <- function(reps = 1000, n = 100, sd = 20, bake = 120){
dist <- data.frame(profit = rep(0, times = reps),
missed = rep(0, times = reps))
for(i in 1:reps){
dist[i, ] <- sim.profit(n = n, sd = sd, bake = bake)
}
plot.profit(dist)
data.frame(MeanProfits = round(mean(dist$profit), 0),
stdProfits = round(sqrt(var(dist$profit)), 0),
MeanMissed = round(mean(dist$missed), 0),
stdMissed = round(sqrt(var(dist$missed)), 0) )
}
system.time(
dist.profit()
)
library(microbenchmark)
microbenchmark(
dist.profit(),
times = 20
)
install.packages('microbenchmark')
library(microbenchmark)
microbenchmark(
dist.profit(),
times = 20
)
test.demand <- function(){
set.seed(2345)
res <- c("white", "white", "wheat", "white", "white", "white",
"wheat", "multi", "white", "wheat", "white", "white",
"white", "white", "white", "white", "wheat", "white",
"wheat", "white")
demand  <- sim.demand(20)
if(!any(demand != res)) print('sim.demand funciton works!')
else print('ERROR: sim.demand failed')
}
test.demand
View(test.demand)
test.demand()
sim.demand(100)
install.packages('hexbin')
install.packages('repr')
install.packages('gridExtra')
install.packages('gridExtra')
install.packages("gridExtra")
install.packages("car")
install.packages("ellipse")
install.packages("corrplot")
